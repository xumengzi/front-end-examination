### 2025-08-27 模拟面试（十）

题目 1：扁平化嵌套数组并求和（加权和）
题目描述：
实现一个函数 flattenAndSum(arr, depth = Infinity)，它可以扁平化一个多维整数数组，并根据其深度计算加权和。
加权规则：每个元素的值为 元素值 \* (最大深度 - 当前深度 + 1)。
深度从 1 开始计数（即最外层的深度为 1）。

示例：

```js
const arr = [1, [2, [3, 4], 5], 6];
// 最大深度为3
// 1 (深度1) -> 1 * (3-1+1) = 3
// 2 (深度2) -> 2 * (3-2+1) = 4
// 3 (深度3) -> 3 * (3-3+1) = 3
// 4 (深度3) -> 4 * (3-3+1) = 4
// 5 (深度2) -> 5 * (3-2+1) = 10
// 6 (深度1) -> 6 * (3-1+1) = 18
// 总和： 3 + 4 + 3 + 4 + 10 + 18 = 42

console.log(flattenAndSum(arr)); // 应输出 42

// 用数组来存放递归后的数据，递归可以计算出每个数据的层数，最后计算这个数组即可算出结果
function flattenAndSum(list) {
  var arr = [];
  var result = 0;
  var maxDeep = 1;
  function fn(list, deep = 1) {
    maxDeep = Math.max(maxDeep, deep);
    list.forEach((item, index) => {
      if (Array.isArray(item)) {
        fn(item, deep + 1);
      } else {
        arr.push({
          value: item,
          deep: deep,
        });
      }
    });
  }
  fn(list);
  for (var i of arr) {
    var sum = i.value * (maxDeep - i.deep + 1);
    result += sum;
  }
  return result;
}
```

题目 5：最长不含重复字符的子字符串（前端变体）
题目描述：
给定一个字符串 s，请你找出其中不含有重复字符的 最长子串 的 长度。
这是一个经典问题，但请尝试用 前端性能分析 的思维来解决。

附加要求：
除了实现算法 lengthOfLongestSubstring(s)，请回答：

你的算法的时间复杂度和空间复杂度是多少？

如果这个字符串是一个用户正在输入的实时流（例如搜索框），如何逐步计算并更新当前最长子串的长度？你的算法能否被修改以适应这种场景？

示例：

```js
console.log(lengthOfLongestSubstring("abcabcbb")); // 3 ("abc")
console.log(lengthOfLongestSubstring("bbbbb")); // 1 ("b")
console.log(lengthOfLongestSubstring("pwwkew")); // 3 ("wke")
```
