### 2025-08-20 模拟面试（三）

##### 一、 JavaScript 核心 & 深度原理

1. 异步编程演进：请阐述从 Callback 到 Promise 再到 Async/Await 的演进过程。

   1. Callback（回调函数）：最原始的异步解决方案，如 setTimeout，fs.readfile。缺点就是当多个异步操作存在依赖关系时，会产生回调地狱，代码晦涩难懂，维护困难。
   2. Promise：ES6 引入，提供了一个更强大的异步管理容器。它将异步操作的成功和失败分离，通过.then()和.catch()进行链式调用，解决了回调地狱的问题，让异步流程更加线性化。但 then 链式调用仍然不够直观
   3. Async 和 Await：ES7 引入，它本质上是 Promise 的语法糖，但让其表现得更像同步代码。用 async 声明一个异步函数，在其内部用 Await 来暂停一个等待的 Promise 的解决结果。这使得异步代码的书写体验跟同步代码几乎一致，可以使用 try/catch 进行错误处理，是当前最优雅的解决方案。

2. 内存管理与闭包：
   1. 请解释 JavaScript 的垃圾回收机制（主要谈谈标记清除即可）。
      从跟对象出发，递归遍历当前所有能够被访问到的对象，并标记为“活跃的”，其他没有被标记的对象就属于不活跃的垃圾，可以被回收掉它们占用的内存
   2. 闭包为什么会容易引起内存泄漏？请列举一个实际开发中由闭包引起内存泄漏的场景以及如何避免。
      如果一个闭包引用了一个外部作用域的大变量（如一个巨大的数组或对象），并且这个闭包本身被长期持有（例如被设置为全局变量、事件监听器、计时器的回调），那么即使这个闭包再也不会被执行，它所引用的整个外部词法作用域（包括那个大变量）都无法被垃圾回收器标记为垃圾，从而造成内存泄漏。
3. 模块化的发展历史
   1. IIFE（立即执行函数）：利用函数作用于模拟模块，避免污染全局，是模块化的雏形
   2. CommonJS：Nodejs 的规范，module.exports 导出,require 导入。同步加载，主要用于服务端。
   3. AMD：RequireJS 推广，define 定义，require 加载。异步加载，专为浏览器设计，解决了 CommonJS 同步加载阻塞的问题。
   4. CMD：Seajs 推广，理念类似 AMD，但是推崇依赖就近，延迟执行。
   5. ES Module（ES6）：语言层面的标准，使用 import/export 语法，静态编译，支持异步加载，是未来的方向。
